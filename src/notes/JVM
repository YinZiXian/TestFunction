·运行时数据区：
	线程私有：
		1.程序计数器:正在执行的虚拟机字节码指令的地址,如果执行的是native方法则为Undefined
			没有规定任何 OutOfMemoryError情况;
		2.虚拟机栈:每个方法执行时会创建一个栈帧,用于存局部变量表,操作数栈,动态链接,方法出口等信息.
				每个方法从调用到结束,对应着一个栈帧的入栈出栈过程
			StackOverflowError/OutOfMemoryError(线程请求的栈深度>虚拟机允许的栈深度/虚拟机可动态扩展&扩展时无法申请到足够的内存);
	
		3.本地方法栈:
			StackOverflowError/OutOfMemoryError(线程请求的栈深度>虚拟机允许的栈深度/虚拟机可动态扩展&扩展时无法申请到足够的内存);
	线程共享:
		4.方法区（non-heap/永久代）:存储已被虚拟机加载的类信息,常量,静态变量,JIT(即时编译器)编译后的代码.内部有一个运行时常量池
			OutOfMemoryError;
		5.堆:存放对象实例和数据,内部划分TLAB(线程私有的分配缓冲区)
			OutOfMemoryError;

·类的生命周期:加载->连接(验证->准备->解析)->初始化->使用->卸载			

·对象创建:
	1.检查类是否已被加载,解析初始化过,如果没有,执行相应的类加载
	2.为对象分配内存:根据垃圾收集器是否带压缩整理的算法决定
		指针碰撞:堆中内存是绝对规整的，用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点
		空闲列表:维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录
		两种解决并发问题的方式：1.CAS+失败重试。2.在各个线程的TLAB上分配
	3.默认初始化和显示初始化
	
·对象的内存布局:
	运行时数据:
		对象头:哈希码,GC分代年龄,锁状态标志,偏向线程ID,偏向时间戳等
		实例数据:
		对齐填充:不必须,保证对象大小是8字节的整数倍
	类型指针:对象指向它的类的元数据指针;如果是数组,还有一块用于记录数组长度的数据

·对象的访问定位:
	句柄访问:在堆中分配一块内存当作句柄池,存放指向堆中对象实例数据的指针和方法区中对象类型信息的指针
	优点:对象移动(GC)时只需要改变句柄池中对象实例的指针
	直接指针访问:对象实例信息中存放指向方法区中类型信息的指针
	优点:一次指针定位即可访问对象数据,hotspot默认使用

·判断对象是否存活:
	引用计数:给对象添加一个引用计数器,引用+1,引用失效-1,计数器为0的对象判定为可回收对象,无法回收循环引用的对象
	可达性分析:用过一系列成为GCRoot的对象节点向下搜索,不可达的对象判定为可回收对象,hotspot默认使用

	
·对象引用类型:
	强引用:只要强引用在就不回收。
	软引用(SoftReference):在系统要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行二次回收。
	弱引用(WeakReference):对象只能生存到下一次垃圾收集之前。在垃圾收集器工作时，无论内存是否足够都会回收掉只被弱引用关联的对象。
	虚引用(PhantomReference):无法通过虚引用获取一个对象的实例，为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。

·finalize() 方法只会被系统自动调用一次。

·回收方法区:主要回收废弃的常量和无用的类
	废弃常量:没有指向该常量的引用
	无用的类:
		1.该类所有的对象实例都已经回收
		2.加载该类的ClassLoader已经被回收
		3.该类对应的Class对象没有任何地方被引用,无法在任何地方通过反射访问该类的方法
		
·垃圾收集算法
	标记-清除算法：标记需要回收的对象，标记完统一回收
		不足：1.效率问题。标记和清除的效率都不高。2.空间问题：标记清除之后会产生大量不连续的空间碎片
	复制算法:Eden:Survivor:Survivor=8:1:1,存活的多于10%多出来的进入老年代
	标记-整理算法:先标记，然后存活的对象向一边移动，清除边界以外的内存

·类加载器:启动类加载器(BootstrapClassLoader)
			<-扩展类加载器(ExtensionClassLoader)
				<-应用程序类加载器(ApplicationClassLoader)
					<-自定义类加载器(UserClassLoader)

·双亲委派模型:如果一个类加载器收到一个类加载的请求，它首先不会自己加载，而是把这个请求委派给父类加载器。只有父类无法完成时子类才会尝试加载。

·新生代进入老年代：
	1.熬过15次Minor GC 
	2.相同年龄对象大小总和>Survival空间的一半，年龄>=该年龄的对象可进入老年代

·