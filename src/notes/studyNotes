·SOLID原则：单一职责原则，开闭原则，里氏替换原则，接口隔离原则，依赖倒置原则
··单一职责原则：类需要修改的原因只有一个。会跑会叫的鸭子
··开闭原则：对扩展开放，对修改关闭。简单工厂和工厂方法模式
··里氏替换原则：派生类型必须完全可替换其基类型。父类引用指向子类对象
··接口隔离原则：客户端不依赖于不需要的接口。会跑会叫的鸭子
··依赖倒置原则：高级模块不依赖于低级模块，两者都依赖抽象；抽象不依赖于细节，细节依赖于抽象

创建型模式：单例，工厂，建造者，原型，对象池
·工厂模式：抽象工厂，具体工厂，抽象产品，具体产品
··简单工厂模式：提供一个静态的工厂方法，根据参数返回不同的子类型
··工厂方法模式：将工厂也抽象，每个子类型提供一个工厂类继承抽象工厂
··抽象工厂模式：扩展自工厂方法，一个工厂类提供多个抽象工厂方法

·浅拷贝对应于聚合关系：包含类独立于外部类；深拷贝对应于组合关系：包含类依赖于外部类存在

·TCP三次握手：信息对等 && 防止请求超时出现脏连接。
··A--B
··第一次：B确认A发报和B收报能力
··第二次：A确认双方收发报能力
··第三次：B确认A收报和B发报能力
··脏连接:A发请求给B，超时后发第二个请求，第二个请求传输结束，第一个请求到达，B以为是新的连接,同意并创建新连接，但是A状态不对，故丢弃了B的确认数据

·TCP四次挥手：
··A发送FIN信号；
··B发送应答ACK信号，告诉A可以断开，需要等B处理完数据，并进入CLOSE_WAIT

··B做好连接关闭前的准备工作之后发送FIN信号；
··A收到信号后发送ACK信号并进入TIME_WAIT：默认2MSL => 240s,可进入/etc/sysctl.conf修改net.ipv4.tcp_fin_timeout = 30(建议小于30s)

·HashMap多线程两个问题：死链问题，扩容数据丢失问题
  
·线程池：
··线程池的作用：提高应用程序的稳定性，因为Web服务器不会在高负载情况下失败：由于服务器不会创建数千个线程来争夺有限的CPU和内存资源，因此服务器的性能将平稳降低（如果在足够长的时间内，任务到达的速率总是超过任务执行的速率，服务器仍有OOM风险，因为workQueue会不断增长，所以ThreadPoolExecutor提供了maximumPoolSize和RejectedExecutionHandler两个参数）
··线程池大小设置：分析计算环境，资源预算和任务特性。比如服务器CPU核数多少?内存多大？I/O密集型还是计算密集型?是否需要JDBC这样的稀缺资源
··任务被提交到已调用shutdown的Executor会执行拒绝策略
··ThreadPoolExecutor可扩展，可在子类中覆写 beforeExecute（这里抛异常，任务和afterExecute都不执行），afterExecute（除非任务抛出ERROR，否则都会执行）和terminated

·死锁产生情况：
··因加锁顺序造成的死锁。解决：根据参数的hash值进行加锁（System.identityHashCode）hash值相同时先获取tieLock锁（加时锁），保证同时只有一个线程获取锁
··协作对象之间的死锁。解决：开放调用。
····开放调用：调用某个方法时不需要持有锁，即调用方法的位置不在锁代码块里
··资源死锁:某些任务需要等待其他任务的结果。有界线程池与相互依赖的任务不能一起使用，例如生产者-消费者

·MySQL中的锁：
··myisam采用表锁，innodb采用行锁（通过给索引项加锁实现，只有通过索引检索数据才会使用行锁，否则使用表锁）
··默认情况下，表锁和行锁都是自动获得的，不需要额外的命令
··行级锁只在存储引擎层实现，服务器层没有实现
··锁分为共享锁和独占锁，默认情况下一个锁释放时，独占锁会优先获取锁
··显式加锁：共享锁：select lock in share mode 独占锁：select for update
··myisam总是一次性获取sql语句所需全部锁，所以不会死锁
··innodb锁是一个个获取的，执行commit或rollback时会同时释放
··innodb通过锁和MVCC实现一致性读
··乐观锁:假设不会发生冲突，只在提交时检查是否违反数据完整性
··悲观锁:假设别人会修改，拿数据的时候就加锁（MySQL中的读写锁均为悲观锁）

·线程开销:1.线程之间的协调.2.上下文切换3.线程创建和销毁.4.线程调度

·降低锁的竞争:
	1.减少锁的持有时间
	2.降低锁的粒度:锁分解,锁分段
	3.降低锁的请求频率
	4.使用带协调机制的独占锁,这些机制允许更高的并发性

·ReentrantLock不是一种替代内置锁的方法,而是内置锁不适用时,一种可选的高级功能
	Lock提供了一种可定时,可轮询,可中断,公平队列,非块结构(连锁式加锁/锁耦合)的锁

·并发标注
	类:@Immutable(不可变的), @ThreadSafe, @NotThreadSafe
	域和方法:@GuardedBy()