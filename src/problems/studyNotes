・SOLID原则：单一职责原则，开闭原则，里氏替换原则，接口隔离原则，依赖倒置原则
・・单一职责原则：类需要修改的原因只有一个
・・开闭原则：对扩展开放，对修改关闭
・・里氏替换原则：派生类型必须完全可替换其基类型
・・接口隔离原则：客户端不依赖于不需要的接口
・・依赖倒置原则：高级模块不依赖于低级模块，两者都依赖抽象；抽象不依赖于细节，细节依赖于抽象

创建型模式：单例，工厂，建造者，原型，对象池
・工厂模式：抽象工厂，具体工厂，抽象产品，具体产品
・・简单工厂模式：提供一个静态的工厂方法，根据参数返回不同的子类型
・・工厂方法模式：将工厂也抽象，每个子类型提供一个工厂类继承抽象工厂
・・抽象工厂模式：扩展自工厂方法，一个工厂类提供多个抽象工厂方法

・浅拷贝对应于聚合关系：包含类独立于外部类；深拷贝对应于组合关系：包含类依赖于外部类存在

・TCP三次握手：信息对等 && 防止请求超时出现脏连接。
・・A--B
・・第一次：B确认A发报和B收报能力
・・第二次：A确认双方收发报能力
・・第三次：B确认A收报和B发报能力
・・脏连接:A发请求给B，超时后发第二个请求，第二个请求传输结束，第一个请求到达，B以为是新的连接,同意并创建新连接，但是A状态不对，故丢弃了B的确认数据

・TCP四次挥手：
・・A发送FIN信号；
・・B发送应答ACK信号，告诉A可以断开，需要等B处理完数据，并进入CLOSE_WAIT
・・B做好连接关闭前的准备工作之后发送FIN信号；
・・A收到信号后发送ACK信号并进入TIME_WAIT：默认2MSL => 240s,可进入/etc/sysctl.conf修改net.ipv4.tcp_fin_timeout = 30(建议小于30s)

・HashMap多线程两个问题：死链问题，扩容数据丢失问题

・线程池的作用：提高应用程序的稳定性，因为Web服务器不会在高负载情况下失败：由于服务器不会创建数千个线程来争夺有限的CPU和内存资源，因此服务器的性能将平稳降低（如果在足够长的时间内，任务到达的速率总是超过任务执行的速率，服务器仍有OOM风险，因为workQueue会不断增长，所以ThreadPoolExecutor提供了maximumPoolSize和RejectedExecutionHandler两个参数）

・线程池大小设置：分析计算环境，资源预算和任务特性。比如服务器CPU核数多少?内存多大？I/O密集型还是计算密集型?是否需要JDBC这样的稀缺资源

・任务被提交到已调用shutdown的Executor会执行拒绝策略

・ThreadPoolExecutor可扩展，可在子类中覆写 beforeExecute（这里抛异常，任务和afterExecute都不执行），afterExecute（除非任务抛出ERROR，否则都会执行）和terminated

・死锁产生情况：
・・因加锁顺序造成的死锁。解决：根据参数的hash值进行加锁（System.identityHashCode）hash值相同时先获取tieLock锁（加时锁），保证同时只有一个线程获取锁
・・协作对象之间的死锁。解决：开放调用。
・・・・开放调用：调用某个方法时不需要持有锁，即调用方法的位置不在锁代码块里
・・资源死锁:某些任务需要等待其他任务的结果。有界线程池与相互依赖的任务不能一起使用，例如生产者-消费者

・

